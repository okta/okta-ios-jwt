# okta-ios-jwt

## Purpose
- Handle decoding and validating a JSON Web Token
- Provide easy interface for idToken validation based on [OIDC 3.1.3.7](http://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation).
  - `iss`
  - `aud` (optionally azp for multiple audiences)
  - `alg` == `RS256`
    - Our library will not support MAC based algorithms until a later version
  - `exp` and `iat` (with default + custom clock-skew)
  - signature
  - `nonce`

## Dependencies

### [JSONWebToken](https://github.com/kreactive/JSONWebToken)
Swift library for decoding, validating, signing, and verifying a JWT. Unfortunatly, it isn't available via Cocoapods, which is how Okta-AppAuth is currently consumed. We will need to point directly to the repo when declaring it as a dependency.

## JWT Verification
For our use case, we need to support the **RSASA-PKCS1-v1_5** signature. This requires either a **DER-encoded X.509** certificate or **PKCS #12**-formatted identity data.

We can create this key by using the modulus and exponent from the matching kid, available on the organization's `/oauth2/default/v1/keys` endpoint.

```swift
// JSONWebToken API

// Get modulus and exponet from key
let modulus = key["n"] // Base64URL decoded string
let exponent = key["e"] // Base64URL decoded string

// Convert string to NSData so it can be handled by library
let modulusData = modulus.data(using .utf8)
let exponentData = exponent.data(using .utf8)

// Create RSAKey
let key = RSAKey.registerOrUpdateKey(
    modulus: modulusData,
    exponent: exponentData,
    tag: "com.okta.jwt.rsatag"
)
```

To validate the token, convert the JWT string into a `JSONWebToken` object, and use the `RSAPKCS1Verifier` method:

```swift
// JSONWebToken API

let jwt: JSONWebtoken
let publicKey: RSAKey // Created above

let validator = RegisteredClaimValidator.expiration &
                RegisteredClaimValidator.notBefore.optional &
                RSAPKCS1Verifier(key : publicKey, hashFunction: .SHA256)
				
let validationResult = validator.validateToken(jwt) // true or valse
```

## Proposed Solution
Let the `OktaJWTValidator` class handle:
  - Verifing the injected `jwt` is formatted as a `jwt`
    - Specifically → Three components separated by a "." (validated via `JSONWebToken` lib)
  - Fetch the key for the matching `kid` from the `idToken` if no key is provided
    - This pertains to a `jwt` that has been signed with a JWS
  - Create the `RSAKey` for signature validation
  - Validate the `jwt` based on passed configuration
  - Returns true or throws an error

### Default usage (`idToken flow`):
The library will attempt to retrieve an RSAKey (via a predefined "tag" matching the "kid").
- If one exists, attempt to validate the idToken
- If one does not exist, remove the cached RSAKey and attempt to retrieve a list of keys from the OpenID Connect metadata discovery document.
  - Cache the `new RSAKey` until it fails

### Optional params (all other jwts):
 - jwk
    - Pass a JSON representation of the key into the `OktaJWTValidator`.
    - The library will extract the modulus/exponent and create `an RSAKey` for signature validation
  - RSAKey
    - The library will use the included `RSAKey` as a means to validate.

## Validation Options
For flexibility, you can pass in a dictionary of `{key: value}` pairs directly into the validation object. Each field will be evaluated during the validation step:

```swift
let validationOptions = [
    "issuer": "https://{yourOktaDomain}.com/oauth2/default",    // String comparison
    "audience": "{clientId}",  	// String comparison to "aud"
    "nonce": "abc123",		// String comparison to "nonce"
    "iat": true, 		// Evaluate the "iat" claim based on current time. Defaults to true
    "exp": true,		// Evaluate the "exp" claim based on current time. Default to true
    "cid": "{clientId}",	// String comparison to "cid" claim
    "leeway": 3000 		// optional clock-skew that is (+/-) to "iat" and/or "exp". Defaults to 3000.
    "customClaim": "customClaimValue" 	// String comparison
    ...
]
```

## Performing Manual Validation
### Best practice
```swift
let jwt = "ey....."

let validationOptions = [
    "issuer": "https://{yourOktaDomain}.com/oauth2/default",
    "audience": "{clientId}",
    "nonce": "abc123"	// typically generated by the client
]

// Attempt to use the /keys endpoint via the well-known endpoint of the "issuer"
let validator = OktaJWTValidator(validationOptions)

do {
    try validator.isValid(idToken) {
        return true
    } catch OktaJWTValidationError.invalidSignature {
        // handle invalid signature
    } catch OktaJWTValidationError.invalidScope {
        // handle invalid scope
    } catch OktaJWTValidatinoError.customClaim {
	// handle invalid claim
    }
}

// Alternatively, convert the thrown error to an optional object
if let isValid = try? validator.isValid(idToken) {
    return "Token is valid!"
} else {
    // Token validation error
}
```

### Additional validation
```swift
// Manual validation

let jwt = "ey....."

let validationOptions = [
    "issuer": "https://{yourOktaDomain}.com/oauth2/default",
    "audience": "https://api.com",
    "cid": "{clientId}",
    "nonce": "abc123",
    "iat": false,
    "leeway": 3000 // optional clock-skew,
    "customClaim": "customClaimValue"
    ...
]

// Attempt to use the /keys endpoint via the well-known endpoint.
let validator = OktaJWTValidator(validationOptions)

// or pass in the JWK yourself
let jwk = [
    "alg": "RS256",
    "e": "AQAB",
    "n":"vFn...",
    "kid":"GN2P...",
    "kty":"RSA",
    "use":"sig"
]
let validator = OktaJWTValidator(validationOptions, jwk: jwk)

// or pass in the RSAKey directly
let validator = OktaJWTValidator(validationOptions, key: RSAKey)

do {
    try validator.isValid(idToken) {
        // pass
    } catch OktaJWTValidationError.invalidSignature {
        // handle invalid signature
    } catch OktaJWTValidationError.invalidScope {
        // handle invalid scope
    } catch OktaJWTValidatinoError.customClaim {
        // handle invalid claim
    }
}

// Alternatively, convert the thrown error to an optional object
if let isValid = try? validator.isValid(idToken) {
    return "Token is valid!"
} else {
    // Token validation error
}
```

## Okta AppAuth SDK Implementation
The validation can act as an interceptor before the tokens are returned in the callback, or take place once the tokens are returned from the [Authorization Response](https://github.com/okta/okta-sdk-appauth-ios#authorization). In the login use case, we return the tokens only if they are validated. If an error occurs, it will be captured via the error response.

### Default Behavior
```swift
import OktaAuth

OktaAuth
    .login()
    .start(self)
    .validate() { response, error in
      	//  JWT validator gets run when the token is returned from the /token endpoint
	// 	By default, we will validate the following (not in order):
	//    	- issuer: From our AppAuth configuration
	// 	- aud: From our AppAuth configuration
	//	- exp, iat: Based on local time
	//	- nonce: From the AppAuth request (this is generated by the AppAuth lib)
	//	- signature: Based on cached RSAKey or by calling /keys

        if error != nil {
	    print(error!)
	    // This can be:
	    //  - jwt decoding/validating error
            //  - authorization error
            //  - etc
	}
                
        // Success
        if let authResponse = response {
            // Store the validated idToken
            OktaAuth.tokens.set(
                value: authResponse.idToken,
                forKey: "idToken"
            )
        }
    }
```

### Override Behavior
```swift
import OktaAuth

let validationOptions = [
    "issuer": "https://{yourOktaDomain}.com/oauth2/default",
    "audience": "{clientId}",
    "iat": true
]

let jwk = [
    "alg": "RS256",
    "e": "AQAB",
    "n":"vFn...",
    "kid":"GN2P...",
    "kty":"RSA",
    "use":"sig"
]

let validator = OktaJWTValidator(validationOptions, jwk: jwk)

OktaAuth
    .login()
    .start(self)
	.validate(validator) { response, error in
      	//  ^ Set the JWT Validator to override the default behavior for the values submitted
	//    Any values untouched will be set to the default behavior

        if error != nil {
	    print(error!)
            // This can be:
            //  - jwt decoding/validating error
            //  - authorization error
            //  - etc
        }
                
        // Success
        if let authResponse = response {
            // Store the validated idToken
            OktaAuth.tokens.set(
                value: authResponse.idToken,
                forKey: "idToken"
            )
        }
    }
```

## Okta iOS Verify Implementation
Currently, we use an outdated Auth0 library to create a JWT, that we pass to Okta for validation. See [okta-ios-verify/OktaAPIClient.m#L113-L153](https://github.com/okta/okta-ios-verify/blob/6e779fed5c101088cecfe3f5922a534449802c06/OktaVerify/src/Core/OktaAPIClient.m#L113-L153)

```swift
// Current (in Swift)

class func jwtClaims(challenge) -> [Any: Any] {
	// Removed some logic for simplicity
    let host = UserDefaults.standard.dictionary(forKey: factorId!)[MFA_HOST]
    let iat = Int(Date().timeIntervalSince1970)
    let exp = Int(Date(timeIntervalSinceNow: 60).timeIntervalSince1970)
    let nbf = Int(Date(timeIntervalSinceNow: -60).timeIntervalSince1970)
    let parameters = [
        "tx": challenge[PUSH_TRANSACTIONID],
        "iss": challenge[PUSH_FACTORID],
        "sub": challenge["userId"],         // UserId
        "aud": host,         		    // host
        "iat": iat,         		    // Now
        "exp": exp,         		    // Now + 1 Mins
        "nbf": nbf,         		    // Now - 1 mins,
        "jti": UUID().uuidString
    ]
    return parameters
}

class func buildJwtToken(_ userInfo: [Any: Any]) -> String {
    let jwtClaims = self.jwtClaims(withChallenge: userInfo)
    let jwtBuilder = A0JWTBuilder()
    jwtBuilder.JWTPayload = jwtClaims
    jwtBuilder.sign(
        withMethod: A0JWTSignMethodRS256,
        andKeyOrSecret: (EncryptionHelper.getPrivateKey(JWT_KEYPAIR_TAG))
    )
    let jwt: String = jwtBuilder.jwt()
    let token = "SSWS \(jwt)"
    return token
}
```

Using the OktaJWTValidator library for signing, this can be modified to:

```swift
class func jwtClaims(challenge) -> [Any: Any] {
    ...
}

class func buildJwtToken(userInfo: [Any: Any]) -> String {
    let jwtClaims = self.jwtClaims(challenge: userInfo)
    let jwtBuilder = OktaJWTSigner(
        payload: jwtClaims,
        alg: .SHA256,
        key: EncryptionHelper.getPrivateKey(JWT_KEYPAIR_TAG)
    )

    let jwt = jwtBuilder.jwt()
    let token = "SSWS \(jwt)"
    return token
}
```

Future Plans
Today, we advise using the default [TokenManager](https://github.com/okta/okta-sdk-appauth-ios/blob/master/Okta/OktaTokenManager.swift) inside of the **Okta AppAuth SDK**. This acts as only a storage mechinism, where the developer can store any string inside of the Apple Keychain. While we do expose the ability to store an item with or without background access, there are several additional use iCloud cases (noteably TouchID).
In the future, we will release an **Access Control SDK**, that integrates directly with the iOS Keychain to store credentials. In theory, all Okta SDKs will inherit from this tool, protecting credentials as they see fit.

```swift
import OktaAuth

let tokenControl = OktaAccessControl(
    touchId: false,
    accessibility: .PASSCODE,
    validate: .IDTOKEN
)

OktaAuth
    .login()
    .start(view: self) { response, error in
      
        if error != nil { print(error!) }
                
        // Success
        if let authResponse = response {
            let idToken = authResponse.idToken

            // Token gets validated and stored via control options
            OktaAuth.tokens.store(
                value: idToken,
                forKey: "idToken",
                control: tokenControl
            )
        }
    }
```
